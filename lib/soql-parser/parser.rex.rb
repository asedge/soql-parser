#--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.5
# from lexical definition file "lib/soql-parser/parser.rex".
#++

require 'racc/parser'
class SOQLParser::Parser < Racc::Parser
  require 'strscan'

  class ScanError < StandardError ; end

  attr_reader   :lineno
  attr_reader   :filename
  attr_accessor :state

  def scan_setup(str)
    @ss = StringScanner.new(str)
    @lineno =  1
    @state  = nil
  end

  def action
    yield
  end

  def scan_str(str)
    scan_setup(str)
    do_parse
  end
  alias :scan :scan_str

  def load_file( filename )
    @filename = filename
    open(filename, "r") do |f|
      scan_setup(f.read)
    end
  end

  def scan_file( filename )
    load_file(filename)
    do_parse
  end


  def next_token
    return if @ss.eos?
    
    # skips empty actions
    until token = _next_token or @ss.eos?; end
    token
  end

  def _next_token
    text = @ss.peek(1)
    @lineno  +=  1  if text == "\n"
    token = case @state
    when nil
      case
      when (text = @ss.scan(/[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}([-+][0-9]{2}:[0-9]{2}|Z)/i))
         action {                  [:datetime, text] }

      when (text = @ss.scan(/[0-9]{4}-[0-9]{2}-[0-9]{2}/i))
         action {                  [:date, text] }

      when (text = @ss.scan(/\'/i))
         action { @state = :STRS;  [:quote, text] }

      when (text = @ss.scan(/\"/i))
         action { @state = :STRD;  [:quote, text] }

      when (text = @ss.scan(/[0-9]+/i))
         action { [:unsigned_integer, text.to_i] }

      when (text = @ss.scan(/\s+/i))
        ;

      when (text = @ss.scan(/<>/i))
         action { [:not_equals_operator, text] }

      when (text = @ss.scan(/!=/i))
         action { [:not_equals_operator, text] }

      when (text = @ss.scan(/=/i))
         action { [:equals_operator, text] }

      when (text = @ss.scan(/<=/i))
         action { [:less_than_or_equals_operator, text] }

      when (text = @ss.scan(/</i))
         action { [:less_than_operator, text] }

      when (text = @ss.scan(/>=/i))
         action { [:greater_than_or_equals_operator, text] }

      when (text = @ss.scan(/>/i))
         action { [:greater_than_operator, text] }

      when (text = @ss.scan(/\(/i))
         action { [:left_paren, text] }

      when (text = @ss.scan(/\)/i))
         action { [:right_paren, text] }

      when (text = @ss.scan(/\*/i))
         action { [:asterisk, text] }

      when (text = @ss.scan(/\//i))
         action { [:solidus, text] }

      when (text = @ss.scan(/\+/i))
         action { [:plus_sign, text] }

      when (text = @ss.scan(/\-/i))
         action { [:minus_sign, text] }

      when (text = @ss.scan(/\./i))
         action { [:period, text] }

      when (text = @ss.scan(/,/i))
         action { [:comma, text] }

      when (text = @ss.scan(/[a-zA-Z_][a-zA-Z0-9_]*:\d+/i))
         action { [:date_literal_with_arg, text] }

      when (text = @ss.scan(/[a-zA-Z_][a-zA-Z0-9_]*/i))
         action { tokenize_ident(text) }

      when (text = @ss.scan(/----/i))
        ;

      when (text = @ss.scan(/require/i))
        ;

      else
        text = @ss.string[@ss.pos .. -1]
        raise  ScanError, "can not match: '" + text + "'"
      end  # if

    when :STRS
      case
      when (text = @ss.scan(/\'/i))
         action { @state = nil;    [:quote, text] }

      when (text = @ss.scan(/.*?(?=\')/i))
         action {                  [:character_string_literal, text.gsub("''", "'")] }

      else
        text = @ss.string[@ss.pos .. -1]
        raise  ScanError, "can not match: '" + text + "'"
      end  # if

    when :STRD
      case
      when (text = @ss.scan(/\"/i))
         action { @state = nil;    [:quote, text] }

      when (text = @ss.scan(/.*?(?=\")/i))
         action {                  [:character_string_literal, text.gsub('""', '"')] }

      else
        text = @ss.string[@ss.pos .. -1]
        raise  ScanError, "can not match: '" + text + "'"
      end  # if

    else
      raise  ScanError, "undefined state: '" + state.to_s + "'"
    end  # case state
    token
  end  # def _next_token

  KEYWORDS = %w(
    SELECT
    ASC
    AS
    FROM
    WHERE
    AND
    NOT
    IN
    ORDER
    OR
    LIKE
    IS
    NULL
    NULLS
    COUNT
    AVG
    MAX
    MIN
    SUM
    GROUP
    BY
    HAVING
    LIMIT
    USING
    DESC
    SCOPE
    FIRST
    LAST
    WITH
    EXCLUDES
    INCLUDES
  )
  DATE_LITERALS_WITHOUT_ARGUMENT = %w(
    YESTERDAY
    TODAY
    TOMORROW
    LAST_WEEK
    THIS_WEEK
    NEXT_WEEK
    LAST_MONTH
    THIS_MONTH
    NEXT_MONTH
    LAST_90_DAYS
    NEXT_90_DAYS
    THIS_QUARTER
    LAST_QUARTER
    NEXT_QUARTER
    THIS_YEAR
    LAST_YEAR
    NEXT_YEAR
    THIS_FISCAL_QUARTER
    LAST_FISCAL_QUARTER
    NEXT_FISCAL_QUARTER
    THIS_FISCAL_YEAR
    LAST_FISCAL_YEAR
    NEXT_FISCAL_YEAR
  )
  DATE_LITERALS_WITH_ARGUMENT = %w(
    LAST_N_DAYS
    NEXT_N_DAYS
    NEXT_N_WEEKS
    LAST_N_WEEKS
    NEXT_N_MONTHS
    LAST_N_MONTHS
    NEXT_N_QUARTERS
    LAST_N_QUARTERS
    NEXT_N_YEARS
    LAST_N_YEARS
    NEXT_N_FISCAL_QUARTERS
    LAST_N_FISCAL_QUARTERS
    NEXT_N_FISCAL_YEARS
    LAST_N_FISCAL_YEARS
  )
  def tokenize_ident(text)
    if KEYWORDS.include?(text.upcase)
      [:"#{text.upcase}", text]
    elsif DATE_LITERALS_WITHOUT_ARGUMENT.include?(text.upcase)
      [:date_literal, text]
    else
      [:identifier, text]
    end
  end
end # class
